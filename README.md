# helm-chart
Helm Chart for Deploying funcX stack

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![NSF-2004894](https://img.shields.io/badge/NSF-2004894-blue.svg)](https://nsf.gov/awardsearch/showAward?AWD_ID=2004894)
[![NSF-2004932](https://img.shields.io/badge/NSF-2004932-blue.svg)](https://nsf.gov/awardsearch/showAward?AWD_ID=2004932)

This application includes:
* FuncX Web-Service
* FuncX Forwarder
* FuncX Endpoint (optional)
* Postgres database
* Redis Shared Data Structure

## FuncX Endpoint

There are two modes in which funcx-endpoints could be deployed:

1. funcx-endpoint deployed outside k8s, connecting to hosted services in k8s
2. funcx-endpoint deployed within k8s

# Deploying funcx-endpoint externally
The following steps setup a local deployment of funcx stack. We can then launch an endpoint against the stack, and launch an sdk to submit tasks to the endpoint.

## Deploy helm-chart
1. Make sure minikube is installed on your local box.
2. We need to make sure minikube is turned on. Use `minikube status` to check that. If not, we can turn it on by `minikube start`.
3. Create a directory within this `helm-chart` directory. In this example, let us call the newly created directory `deployed_values`.
4. Create a `.yaml` file within the `deployed_values` directory. In this example, let us call the `.yaml` file `dev_values.yaml`.
5. Use the following as a template for `dev_values.yaml`. All the parameters as shown below are tested working.
We need to obtain the `globusClient` and `globusKey` and replace them in the template.
``` yaml
webService:
  image: funcx/web-service
  pullPolicy: Always
  host: http://localhost:5000
  globusClient: <GLOBUS_CLIENT_ID_STRING>
  globusKey: <GLOBUS_CLIENT_KEY_STRING>
  tag: main

endpoint:
  enabled: false
funcx_endpoint:
  image:
    tag: exception

forwarder:
  enabled: true
  tag: main
  pullPolicy: Always
  image: funcx/forwarder

redis:
  master:
    service:
      nodePort: 30379
      type: NodePort
postgresql:
  service:
    nodePort: 30432
    type: NodePort
```
6. We can now deploy the funcx stack locally by `helm install -f deployed_values/dev_values.yaml funcx ./funcx`.
7. We may need to wait for a minute or two for all the applications to be fully deployed. We can check the deployment status by
`kubectl get pods --namespace default`
8. We need to follow the notes generated by the installation command, to assign proxy for the web service running in the cluster.
`export POD_NAME=$(kubectl get pods --namespace default -l "app=funcx-funcx-web-service" -o jsonpath="{.items[0].metadata.name}")`
`kubectl port-forward $POD_NAME 5000:5000`
9. We can test the deployment by entering `http://127.0.0.1:5000/api/v1/version` in a browser. At the same time, we should be able to notice on-screen printout of `Handling connection for 5000`.
10. Now we can start a funcx endpoint against the local deployed the funcx stack.

## Start an endpoint
0. Install FuncX if not yet.
``` shell
git clone https://github.com/funcx-faas/funcX.git
cd funcX
git checkout main
pip install ./funcx_sdk
pip install ./funcx_endpoint
```
1. In a new console, run `funcx-endpoint configure local-helm` for a new endpoint configuration.
2. In `~/.funcx/local-helm` locate the `config.py` file.
3. We need to change `funcx_service_address` in the file to
`funcx_service_address="http://127.0.0.1:5000/api/v1`
4. Then we can launch an endpoint by `funcx-endpoint start local-helm`
5. We need the endpoint uuid for the following steps.

## Submit function from an sdk to the endpoint
1. Use the following code to create a `.py` file. In this example, let us name it `test_local.py`.
``` python
from funcx.sdk.client import FuncXClient
import time

def hello_world():
    return "Hello World!"

fxc = FuncXClient(funcx_service_address="http://127.0.0.1:5000/api/v1")

func_uuid = fxc.register_function(hello_world)
print(func_uuid)

local_endpoint = <THE ENDPOINT UUID FROM THE PREVIOUS STEP>
res = fxc.run(endpoint_id=local_endpoint, function_id=func_uuid)
print(res)

time.sleep(5)

print(fxc.get_result(res))
```
2. By running `python test_local.py`, we should expect on-screen printout of `Hello World!`, along with the uuids.

## Clean up
1. We should stop the endpoint by `funcx-endpoint stop local-helm`
2. We can stop the port proxy by Ctrl+c, and stop the cluster by `helm uninstall funcx`
3. We can stop the minikube by `minikube stop`.

# Deploying funcx-endpoint internally
The following steps setup a local deployment of funcx stack, including endpoint.

## Deploy helm-chart
1. Make sure minikube is installed on your local box.
2. We need to make sure minikube is turned on. Use `minikube status` to check that. If not, we can turn it on by `minikube start`.
3. We want to use `helm dependency update` for the latest charts.
4. Create a directory within this `helm-chart` directory. In this example, let us call the newly created directory `deployed_values`.
5. Create a `.yaml` file within the `deployed_values` directory. In this example, let us call the `.yaml` file `dev_values.yaml`.
6. Use the following as a template for `dev_values.yaml`. All the parameters as shown below are tested working.
We need to obtain the `globusClient` and `globusKey` and replace them in the template.
``` yaml
webService:
  image: funcx/web-service
  pullPolicy: Always
  host: http://localhost:5000
  globusClient: <GLOBUS_CLIENT_ID_STRING>
  globusKey: <GLOBUS_CLIENT_KEY_STRING>
  tag: main

endpoint:
  enabled: true

funcx_endpoint:
  funcXServiceAddress: http://funcx-funcx-web-service:8000/
  image:
    repository: funcx/kube-endpoint
    tag: main
    pullPolicy: Always

  workerImage: python:3.7-buster
  workerInit: pip install --force-reinstall git+https://github.com/funcx-faas/funcX.git#subdirectory=funcx_endpoint;pip install --force-reinstall git+https://github.com/funcx-faas/funcX.git#subdirectory=funcx_sdk
  workerNamespace: default
  logDir: /tmp/worker_logs

  rbacEnabled: true
  nameOverride: funcx-endpoint

  initMem: 2000Mi
  maxMem: 16000Mi
  initCPU: 1
  maxCPU: 2

  initBlocks: 0
  minBlocks: 1
  maxBlocks: 100
  maxWorkersPerPod: 1

  detachEndpoint: true

  endpointUUID: d2d612a2-cda9-42aa-a766-1a5657b0a5e7

forwarder:
  enabled: true
  tag: main
  pullPolicy: Always
  image: funcx/forwarder

redis:
  master:
    service:
      nodePort: 30379
      type: NodePort
postgresql:
  service:
    nodePort: 30432
    type: NodePort
```
Note: endpointUUID cannot be a random string. It needs to satisfy UUID requirement.

7. We can now deploy the funcx stack locally by `helm install -f deployed_values/dev_values.yaml funcx ./funcx`.
8. We may need to wait for a minute or two for all the applications to be fully deployed. We can check the deployment status by
`kubectl get pods --namespace default`
9. We need to follow the notes generated by the installation command, to assign proxy for the web service running in the cluster.
`export POD_NAME=$(kubectl get pods --namespace default -l "app=funcx-funcx-web-service" -o jsonpath="{.items[0].metadata.name}")`
`kubectl port-forward $POD_NAME 5000:5000`
10. We can test the deployment by entering `http://127.0.0.1:5000/api/v1/version` in a browser. At the same time, we should be able to notice on-screen printout of `Handling connection for 5000`.
11. Now we can submit a function to the internally deployed endpoint.

## Submit function from an sdk to the endpoint
1. Use the following code to create a `.py` file. In this example, let us name it `test_local.py`.
``` python
from funcx.sdk.client import FuncXClient
import time

def hello_world():
    return "Hello World!"

fxc = FuncXClient(funcx_service_address="http://127.0.0.1:5000/api/v1")

func_uuid = fxc.register_function(hello_world)
print(func_uuid)

local_endpoint = 'd2d612a2-cda9-42aa-a766-1a5657b0a5e7'
res = fxc.run(endpoint_id=local_endpoint, function_id=func_uuid)
print(res)

time.sleep(120)

print(fxc.get_result(res))
```
Note: The endpoint UUID we are using here is the one used in the deployment yaml file. We want to give it a 120-second wait time, for the overhead of manager pod creation. After running the script for the first time, the wait time can be reduced to a couple of seconds.

2. By running `python test_local.py`, we should expect on-screen printout of `Hello World!`, along with the uuids.

## Clean up
1. We can stop the port proxy by Ctrl+c, and stop the cluster by `helm uninstall funcx`
2. We may also want to use `kubectl delete pods` to manually clean up created manager pod.
3. We can stop the minikube by `minikube stop`.

There are a few values that can be set to adjust the deployed system configuration

| Value                          | Desciption                                                          | Default           |
| ------------------------------ | ------------------------------------------------------------------- | ----------------- |
| `webService.image`             | Docker image name for the web service                               | funcx/web-service |
| `webService.tag`               | Docker image tag for the web service                                | main |
| `webService.pullPolicy`        | Kubernetes pull policy for the web service container                | Always |
| `webService.loglevel`          | Setting for the App logging level                                   | DEBUG          |
| `webService.advertisedRedisPort` | Redis port that the forwarder (outside of cluster) can reach | 30379 |'
| `webService.advertisedRedisHost` | Redis host that the forwarder (outside of cluster) can reach | localhost |'
| `webService.globusClient`      | Client ID for globus app. Obtained from [http://developers.globus.org](http://developers.globus.org) | |
| `webService.globusKey`         | Secret for globus app. Obtained from [http://developers.globus.org](http://developers.globus.org) | |
| `webService.replicas`          | Number of replica web services to deploy                            | 1 |
| `endpoint.enabled`            | Deploy an internal kubernetes endpoint? | true |
| `endpoint.replicas`            | Number of replica endpoint pods to deploy | 1 |
| `endpoint.image`             | Docker image name for the endpoint                               | funcx/kube-endpoint |
| `endpoint.tag`               | Docker image tag for the endpoint                                | main |
| `endpoint.pullPolicy`        | Kubernetes pull policy for the endpoint container                | Always |
| `forwarder.enabled`            | Deploy an internal kubernetes forwarder? | true |
| `forwarder.minInterchangePort`    | The minimum port to assign interchanges. This will be the first port opened int he pod | 54000 |
| `forwarder.maxInterchangePort`    | The maximum port to assign interchanges. Only the first three ports are opened in the pod | 54002 |
| `forwarder.image`             | Docker image name for the forwarder                               | funcx/forwarder |
| `forwarder.tag`               | Docker image tag for the forwarder                                | main |
| `forwarder.pullPolicy`        | Kubernetes pull policy for the forwarder container                | Always |
| `ingress.enabled`              | Deploy an ingres to route traffic to web app?                       | false |
| `ingress.host`                 | Host name for the ingress. You will be able to reach your web service via a url that starts with the helm release name and ends with this host | uc.ssl-hep.org |
| `services.postgres.enabled`      | Deploy postgres along with service?                             | true |
| `services.postgres.externalURI`  | If postgres is deployed externally, what URI connects to it?    | sqlite:////sqlite/app.db |
| `services.redis.enabled`         | Deploy redis along with service?                             | true |
| `services.redis.externalHost`  | If redis is deployed externally, what is the host name?    |  |
| `services.redis.externalPort`  | If redis is deployed externally, what is the port?    |  30379 |


## Subcharts
This chart uses two subcharts to supply dependent services. You can update
settings for these by referenceing the subchart name and values from
their READMEs.

For example
``` yaml
postgresql.postgresqlUsername: funcx
```
| Subchart   | Link to Documentation |
| ---------- | --------------------- |
| postgresql | [https://github.com/bitnami/charts/tree/master/bitnami/postgresql](https://github.com/bitnami/charts/tree/master/bitnami/postgresql) |
| redis      | [https://github.com/bitnami/charts/tree/master/bitnami/redis](https://github.com/bitnami/charts/tree/master/bitnami/redis) |
